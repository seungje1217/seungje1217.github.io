---
layout: single
title: "📘 소프트웨어공학 6 7 8장 정리"
toc: true
toc_sticky: true
toc_label: "목차"
categories: school
excerpt: "소프트웨어공학 6 7 8장 정리"
tag: [school]
---

# 6장 설계 원리

## 설계
요구분석 : 무엇을 만들가를 다루는 작업

설계 : 어떻게 실현할 것인가를 구체적으로 결정하는 활동
- 기본 구조 설계 : 아키텍처 설계 (각 모듈의 역할과 인터페이스 설계)
- 상세 설계 : 모듈 내부의 알고리즘, 데이터를 명세화

전통적 설계 원리
- 분할 정복, 추상화, 합성 등의 원리 적용

아키텍처 기반 설계 (최근)
- 서브시스템, 모듈 개념, 설계 작업의 관점, 설계 작업 과정 숙지
    - 아키텍처
        - 시스템을 구성하는 컴포넌트와 컴포넌트 상호작용의 집합
    - 서브시스템
        - 시스템의 복잡도를 줄이기 위해 분할한 것

설계 관점과 표현방법
- 모듈 관점
    - 일정한 책임을 구현한 코드 단위인 모듈과 그 관계
- 컴포넌트 관점
    - 실행 시 동작하는 요소와 상호작용
- 할당 관점
    - 소프트웨어의 하드웨어설치, 작업 할당, 구현, 데이터 저장에 대한 관점

## 품질 목표
비기능적 요구를 설계 목표로 구체적으로 명시

설계안 중 최적안을 골라내는 작업

## 전통적인 설계 원리
효율성
- 처리 시간과 기억 공간 (처리 속도와 메모리 사용량 최소화)

단순성
- 유지보수성에 영향을 주는 가장 중요한 특성

**추상화**
- 특정 목적에 관련된 정보에 집중 / 나머지 무시

**캡슐화**
- 추상화된 대상이 제공하는 서비스를 쉽게 접근하게 함
- 정보 은닉
- 핵심 정보만 외부에 노출

**모듈화**
- 문제를 소프트웨어의 구성요소가 될 만한 수준으로 분할하는 과정 (큰 시스템 -> 작은 단위로 분할)

## 결합
: 모듈 간에 서로 의지하는 정도
> 결합도 낮을수록 좋음

![image](/assets/images/sw/image2.png)

내용 결합
- 한 모듈의 다른 모듈의 내용 직접 참조

공통 결합
- 한 모듈이 다른 모듈이 읽은 전역 변수 값을 쓰거나 변경

제어 결합
- 한 모듈이 다른 모듈의 제어흐름 경로 결정

스탬프 결합
- 복잡한 데이터 구조에 일부만 사용하는 모듈에 복잡한 데이터 구조를 전달 시

데이터 결합
- 모듈들이 주고받는 매개변수가 간단한 타입이거나 레코드 안의 필드더라고 단순 타입인 경우 
- 간단(단순)한 데이터만 주고받음

## 응집
: 하나의 모듈 안에서 수행되는 작업들이 서로 관련된 정도
> 응집도가 높을 수록 좋음 -> 재사용 쉬우며 이해하기 좋음

우연적 응집
- 단위안 요소들이 의미적으로 아무 관계 없음

논리적 응집
- 본질적으로 다르더라도 같은 범주의 기능을 수행 (논리적 분류)

시간적 응집
- 프로그램 실행의 특정한 시간에 처리되므로 한 그룹 안 (동일 시점 처리)

절차적 응집
- 모듈안에서 실행되는 연산이 프로그램에서 수행되는 순서와 관련 (순서대로 처리되는 기능 묶음)

교환적 응집
- 모듈 내부의 요소들이 동일한 데이터 조작하기에 그룹화

기능적 응집
- 하나의 기능에 모두 기여하고 밀집적 관련 (하나의 명확한 기능 수행)


## 객체지향 설계 원리
인터페이스와 구현의 분리
- 컴포넌트의 공개 인터페이스(프로토타입)와 컴포넌트 상세화의 분리

<br/>

1. 단일 책임의 원리
    - 클래스의 역할과 책임을 단일화 -> 클래스 변경 이유를 하나로 제한

2. 개방 폐쇄의 원리
    - 소프트웨어 객체가 확장을 위해 열려 있어야 하지만 수정을 위해서는 닫혀있어야함

3. 리스코프 교체의 원리
    - 하위 클래스가 상위 클래스로 대체 (기능 손상x)

4. 인터페이스 분리의 원리
    - 클라이언트가 사용하지 않은 인터페이스를 강제로 구현x
        - 비만 인터페이스
        - 오염된 인터페이스
    - 클라이언트가 필요한 기능만

5. 의존 관계 역전의 원리
    - 구체화 된 모듈이 추상화 된 모듈에게 의존이 역전되도록 설계 
    - **구체화 < 추상화**

## 설계 메트릭
전통적인 메트릭
- 크기
- 복잡도
- 결합도
- 응집도
- 정보흐름

객체지향 메트릭
- 클래스 수
- 상속 깊이
- 응집도
- 책임도 등

<br/>
<br/>
<br/>

# 7장 아키텍처와 패턴
## 아키텍처 설계
소프트웨어를 서브시스템으로 나눔 (**서브시스템의 덩어리화** 작업)

시스템 구성요소의 역할 및 관게에 대한 설계

아키텍처 역할
- 시스템의 구조와 방향을 잡아주는 개발의 중심축
- 설계 + 구현과 통합 + 테스팅

## 아키텍처 스타일
: 일반적인 모양과 조화를 위한 스타일을 정하는 작업

| 스타일                      | 설명                          | 장점/단점                     |
| ------------------------ | --------------------------- | ------------------------- |
| **클라이언트 서버형**            | 중앙 서버가 자원을 제공, 클라이언트가 요청    | 중앙집중화, 보안 강화 / 병목, 비용, 비강인성      |
| **계층형**        | 기능을 수직으로 상호작용하는 여러 계층으로 분할 | 추상화, 캡슐화, 재사용 / 커뮤니케이션 제약 |
| **이벤트 기반**               | 이벤트 생산자-소비자로 구성             | 실시간 반응 / 동기화 어려움          |
| **MVC**                  | 모델, 뷰, 컨트롤러 분리  | 관심사 분리, 유지보수 용이           |
| **파이프-필터**               | 필터들이 데이터를 순차적으로 처리          | 병렬성, 단순함 / 자원 낭비       |
| **데이터 중심 (블랙보드, 리파지토리)** | 공유 저장소와 접근자 / 제어 스레드 있음     | 중앙화된 데이터 처리 가능            |
| **Peer-to-Peer**         | 모든 컴포넌트가 클라이언트이자 서버         | 대칭적, 분산 처리 / 관리 어려움       |


## 디자인 패턴
: 설계 단계에서 반복적으로 발생하는 문제에 대한 해결책을 재사용 가능하게 정리한 것

장점
- 쉽게 재사용 가능
- 설계 작업이 쉬워짐
- 설계 관련 지식 정리
- 의사소통 쉬워짐

<br/>

| 패턴                 | 설명                    | 
| ------------------ | --------------------- | 
| **싱글톤**            | 객체를 단 하나만 생성          |           
| **반복자** | 집합 내부구조 몰라도 집합 소속 요소들 쉽게 접근     |
| **어댑터**            | 호환 안 되는 인터페이스 → 맞춤 변환 |
| **데코레이터**          | 합 관계 + 위임 -> 기존 클래스 동작을 가볍고 유연하게 확장           | 
| **팩토리 메소드**        | 객체 생성 책임을 서브클래스에 위임   |
| **추상 팩토리**         | 관련 객체들의 패밀리 생성        | 
| **상태**             | 상태에 따라 객체의 동작이 달라짐    | 
| **옵서버**            | 데이터 보관(Subject) -> 데이터를 이용(옵서버)와 효과적으로 통신하면서 느슨하게 결합     | 

## 아키텍처 평가 기법
: 아키텍처나 디자인 패턴의 속성, 강점 및 약점을 결정하는 방법

SAAM
- 아키텍처가 시나리오 실행 여부 결정
    - 실행 못하는 경우 실행할 수 있도록 아키텍처 변경
- 시나리오
    - 직접 : 시스템의 변경이 요구되지 않는 시나리오
    - 간접 : 시스템의 변경 요구 (새로운 기능 추가, 기능 삭제)

ATAM
- 여러가지 품질 속성에 초점을 맞추어 평가 -> 아키텍처의 Trade-off, 설계 타협점을 찾아냄

<br/>
<br/>
<br/>

# 8장 UI 설계
##  UI 설계
사용자와의 상호작용 설계
- 상호작용 요소
- 워크플로우

사용용이성
- 제품의 차별화 요소

여러분야의 지식과 관련

## 사용성
시스템이 얼마나 쉽게 사용할 수 있는가를 나타내는 척도

주요 요소
- 학습용이성
- 효율성
- 기억용이성
- 낮은 오류율
- 자신감과 만족

## 멘탈 모델
현실 세계 사물이나 과정이 어떻게 작동하는지에 대한 개인의 이해

## 피드백
명령 처리 결과를 사용자에게 명확히 보여주는 것 
    - 로딩 표시

## 제약
매뉴얼 없이도 쉽게 사용할 수 있도록 유도 -> 사용자의 오류를 줄임

## UI 설계 원리
1. 단순하고 자연스럽게 만들기

2. 오류 회복이 쉽고 안전한 사용

3. 직접 조작, 즉각적인 피드백 제공

4. 일관성 유지

5. 즉각적 만족

6. 단축 명령 제공

7. 인식하기 쉬운 구성

8. 공간 기억 활용

9. 접근성 향상

10. 도움말과 문서는 최후의 수단

## UI 설계 과정
![image](/assets/images/sw/image3.png)

사용자 분석
- 사용자 유형
    - 초보자
    - 청소년
- 사용자 유형에 대한 질문

태스크 분석
- 소프트웨어가 수행 할 작업을 분석
- 유스케이스 별로 UI 흐름 파악
- 하위 작업간의 정보 흐름 -> GUI 내용 결정

UI 설계 및 구현
- GUI 디자인 -> 코드에 구현
- 사용되는 개념
    - 마법사 : 미리 저장된 순서로 안내
    - 사이트 이동경로
    - 메타포 : 사용자의 개념적 인식 모델

사용성 테스트
- 테스트 목적 설정
    - 학습성, 오류율, 예측성
- 대표 사용자 설정 (5인 이상)
- 설문 준비 및 테스트

## UI 요소

| 구성 요소        | 설명                |
| ------------ | ----------------- |
| **윈도우**      | 응용 프로그램의 내용 표시 영역 |
| **탭**        | 여러 인스턴스 실행하는 별도의 창        |
| **메뉴**       | 표준 명령의 배열         |
| **아이콘**      | 프로그램을 나타내는 작은 그림  |
| **커서**       | 포인터            |
| **명령 버튼**    | 명령 입력용 버튼         |
| **다이얼로그 박스** | 사용자 입력을 위한 창      |
| **텍스트박스**      | 메시지 표시 또는 입력 필드    |
| **토글버튼**       | on/off 상태 전환 버튼     |
| **리스트박스**      | 후보 리스트 표시          |
| **드롭다운 리스트박스** | 선택 가능한 항목을 펼쳐서 보여줌 |
| **라디오버튼**      | 여러 항목 중 하나 선택      |
| **체크박스**       | 복수 항목 선택 가능        |

## 화면 설계

쉽게 배우고 사용할 수 있어야 함

콤보박스 등으로 입력 오류 최소화

항목 입력 완료 키 설정 필요

## 출력물 설계

주로 인쇄 리포트

가독성이 중요, 전문적이고 매력적인 디자인

머리말/꼬리말 필수

항목은 논리적 순서 및 그룹화 필요

