---
layout: single
title: "📘 소프트웨어공학 9 10 11장 정리"
toc: true
toc_sticky: true
toc_label: "목차"
categories: school
excerpt: "소프트웨어공학 9 10 11장 정리"
tag: [school]
---

# 9장 코딩
## 설계에서 코드 생성
IDE 도구 활용

연관의 코딩
- 1대 1 : 한 클래스가 다른 클래스의 참조를 멤버로 가짐 (필요 시 양방향 참조 가능)
- 1대 N : 한 클래스가 다른 클래스들의 컬렉션(List 등) 을 멤버로 가짐
- N대 N : 중간에 연관 클래스를 도입하여 1:N 관계로 변경하여 구현

시퀀스 다이어그램의 구현
- 객체 간 메세지 흐름이 시퀀스다이어그램에 나타나있다면 메세지를 받는 클래스에 해당 메서드 정의

## 리팩토링
- 결과 변경 없이 코드 구조 재조정
- 이미 존재하는 코드 디자인 안전하게 향상
- 가독성 높이고 유지보수 편하게
- 버그 쉽게 찾음
- 소프트웨어 디자인 개선, 이해하기 쉽게
- 프로그램 빨리 작성

리펙토링 과정

![image](/assets/images/sw/image4.png)


## 코드스멜
: 프로그램에 대한 작업을 어렵게 만드는 것

| 코드 스멜          | 설명                |  리펙토링                |
| -------------- | ----------------- | -------------------- |
| 중복 코드          | 동일 코드가 여러 위치에 있음  | 중복 제거                |
| 긴 메서드          | 너무 많은 로직 포함       | 메서드 분리               |
| 큰 클래스          | 역할이 너무 많음         | 클래스 분할               |
| 긴 파라미터 리스트     | 너무 많은 인자          | 파라미터  개수 줄임               |
| 두가지 이상 이유로 수정되는 클래스 | 클래스는 한 가지 종류의 책임만을 수행x | 한 가지 이유만으로 수정 |

## 코드 품질 향상 기법

- 코드 인스펙션
    - 프로그램을 읽어보고 눈으로 확인
    - 코드의 결함을 찾아내는 기법


- 정적 분석
    - 수행되지 않는 데드코드, 선언x 변수 검사
    - 결함을 찾아내는 기법
    - 자료변칙
    - 사족 : 컴파일러에 의해 검출 x (중복된 배정문 등)

- 페어 프로그래밍

<br/>
<br/>
<br/>

# 10장 테스트
: 오류를 발견 + 프로그램 실행
- 결함을 낮추는 방법
    - 방지 : 인스펙션, 정적 분석
    - 식별하고 제거 : 테스트, 디버깅

- 검증 : 제품을 올바르게 구축하고 있는가?
- 확인 : 올바른 제품을 만들고 있는가?

## 테스트의 기초
- 버그 
- 오류 : 개발자가 잘못 설계, 코딩 실수
- 결함 : 오류의 결과
- 고장 : 시스템이 원하는 작업 수행 x

## 테스트 작업 과정
1. 무엇을 점검할지 결정
2. 테스트 방법 결정
3. 테스트 케이스 개발
4. 예상되는 올바른 결과 작성
5. 테스트 케이스 실행

![image](/assets/images/sw/image5.png)

- 테스트 케이스
    - 결함을 검사할 수 있는 입력
    - 시험조건, 테스트 데이터, 예상 결과
    - 테스트 케이스 명세서

## 블랙박스 테스트
: 내부 경로에 대한 지식은 보지 않고 테스트 대상의 기능이나 성능 테스트
- 요구 사항 및 사양을 기반

## 화이트박스 테스트
: 모듈의 논리적인 구조 점검 - 구조적 테스트

## 상태 기반 테스팅
- 같은 입력 같은 동작을 보이는 동일한 결과를 생성하는 시스템 대상
    - 배치 처리 시스템
    - 계산 중심 시스템
    - 하드웨어 구성 회로

- 시스템 동작은 시스템 상태로 좌우
- 상태 모델 구성요소
    - 상태 : 시스템의 과거 입력에 대한 영향 표시
    - 트랜잭션 : 이벤트에 대한 반응 (시스템이 어떻게 변해가는지)
    - 이벤트 : 시스템에 대한 입력
    - 액션 : 이벤트에 대한 출력

## 통합 테스트
- 모듈의 인터페이스 결합을 테스트
- 모듈 결합 순서에 따라 방법이 다름
    - 빅뱅
    - 하향식 (제품구매 -> 로그인)
    - 상향식 (로그인 -> 제품구매)
    - 연쇄식

## 시스템 및 인수 테스팅
- 컴포넌트 통합 후 수행

<br/>

- 기능 테스트 : 기능적 요구와 시스템의 차이 발견
- 성능 테스트 : 시스템의 여러측면 테스트
    - 작업 부하 : 작업의 양
    - 처리량 : 트랜재션의 수
    - 반응 시간 : 시스템 요구 총 시간
    - 효율성 : 자원효율성
    - 방법
        - 스트레스 테스트
        - 성능 테스트
        -  보안 테스트
- 보안 테스트
- UI 테스트 : UI 결함, 엑터-시스템 사이 동작 결함 찾기 등
- 사용성 테스트
- 인수 테스트 : 당장 사용 가능한지 -> 의뢰자 또는 대리인이 진행
    - 알파 테스트 : 개발 환경에서 실험
    - 베타 테스트 : 외부 환경에서 실험
- 설치 테스트

<br/>
<br/>
<br/>

# 11장 유지보수
: 개발 후에 이루어지는 소프트웨어 변경 작업
- 레거시 시스템
    - 대체하려면 비용이 많이듦
    - 지식, 경험, 지능이 녹아있다
- 여러가지 이유로 수정 후 배포하는 작업
    - 버그 제거
    - 운영 환경의 변화
    - 정부 정책 변화
    - 비즈니스 절차 변화

## 유지보수 유형
    - 수정형 유지보수 : 결함을 고치기 위한 수정
    - 적응형 유지보수 : 변경된 환경에도 사용할 수 있도록 
    - 완전형 유지보수 : 성능이나 유지보수 성을 개선하기 위해 수정
    - 예방형 유지보수 : 오류 발생을 방지하기 위해 수정

## 유지보수 작업 과정
1. 현재 프로그램 이해
2. 변경 파악과 분석
3. 변경 영향 파악 : 이해당사자들에게 알리고 피드백
4. 변경 구현, 테스트, 설치

- 유지보수 작업 분포

![image](/assets/images/sw/image6.png)

## 형상 관리
: 개발 주기 동안 생성된 문서를 관리, 소프트웨어 시스템과 컴포넌트 상태 추적

베이스 라인 : 소프트웨어 형상 항목의 집합
- 소프트웨어 중요한 상태 정의
- 프로덕트가 특정 상태에 이르렀는지
- 계속되는 개발, 유지보수 작업의 기준

필요성
- 소수의 개발자가 한 자리에서 한다면 필요x
- 많은 팀과 개발자들이 동기화 할 경우 필요
- 여러 버전을 유지해야하는 경우

절차
- 소프트웨어 형상 파악
- 형상 변경 제어
    - 변경 이유 파악
    - 변경 분석
    - 변경 제안 준비
    - 변경 제안 평가
    - 변경 추가
- 소프트웨어 형상 검사
- 소프트웨어 형상 상태 보관

형상 감사
- 베이스라인을 구축하기 위한 메커니즘 정의
- 형상 항목 검토
- 형상 항목 확인

## 역공학
: 대상 시스템 분석 -> 시스템의 컴포넌트와 관계 다른 표현이나 더 높은 수준으로 변경

작업 순서

![image](/assets/images/sw/image7.png)

용도
- 프로그램의 이해
- 정형적 분석
- 테스트 케이스 생성
- 리엔지니어링 : 시스템, 컴포넌트 재구조화

재문서화 : 같은 추상 수준을 가진 표현을 생성
- 시스템의 다른 관점
- 보유 문서 개선
- 새로 수정된 프로그램 문서화
